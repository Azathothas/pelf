#!/bin/sh

[ "$DEBUG" = "1" ] && set -x
[ -z "$oPATH" ] && {
    oPATH="$PATH"
    PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
}

CMD="$1"
_cat() {
    files="$*"
    for file in $files; do
        while IFS= read -r line || [ -n "$line" ]; do
            printf '%s\n' "$line"
        done < "$file"
    done
}
FALLBACK="$(_cat "/usr/local/bin/default")"

__RESET="\033[0m"
log() {
    __YELLOW="\033[0;33m"
	printf >&2 "Traceback: AppRun -> (rootfs)/usr/local/bin/LAUNCH ${__YELLOW}INFO${__RESET}: %s\n" "$*"
}
error() {
    __RED="\033[0;31m"
	printf >&2 "Traceback: AppRun -> (rootfs)/usr/local/bin/LAUNCH ${__RED}ERROR${__RESET}: %s\n" "$*"
	exit 1
}

# Execute the command if it exists
execute_command() {
    _cmd="$1"
    shift
    if _cmd="$(command -v "$_cmd")" >/dev/null 2>&1; then
        PATH="$oPATH"
        shift
        exec "$_cmd" "$@"
        return 0
    elif [ -x "$_cmd" ]; then
        shift
        exec "$_cmd" "$@"
    fi
    return 1
}

# Attempt to run ARGV0 command first
if [ -n "$ARGV0" ] && execute_command "${ARGV0#./}" "$@"; then
    :
# Then check the main CMD derived from ARGS
elif [ -n "$CMD" ] && execute_command "$CMD" "$@"; then
    :
# Lastly, check for the fallback command
elif [ -n "$FALLBACK" ] && execute_command "$FALLBACK" "$@"; then
    :
else
    log "W: DEBUG INFO:"
    log "        \$CMD: $CMD"
    log "         \$@: " "$@"
    log "         \$0: $0"
    log "       \$SELF: $SELF"
    log "   \$FALLBACK: $FALLBACK"
    log "  \$SELF_ARGS: $ARGS"
    error "Error: Neither ARGV0 ('${ARGV0%.*}') nor the supplied argument ('$CMD') are available in \$PATH"
fi
