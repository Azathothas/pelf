#!/bin/sh

[ "$DEBUG" = "1" ] && set -x

# Remove the first character ('!') from ARGS for command extraction
ARGS="${ARGS#?}" #ARGS="$(echo "$ARGS" | cut -c2-)"

# Split ARGS into command and arguments
set -- $ARGS
CMD="$1"
shift # Remove CMD, leaving arguments in $@

file_reader() {
    files="$*"
    for file in $files; do
        while IFS= read -r line || [ -n "$line" ]; do
            printf '%s\n' "$line"
        done < "$file"
    done
}

# Define FALLBACK as content of /entrypoint if it exists
[ -f "/usr/local/bin/default" ] && FALLBACK_CMD="$(file_reader "/usr/local/bin/default")"

# Check for ARGV0 command availability (remove "./" if prefixed)
ARGV0_CMD="${ARGV0#./}"

# Sequentially attempt each command, and fallback to a harmless default if all fail
if command -v "$ARGV0_CMD" >/dev/null 2>&1; then
    exec "$ARGV0_CMD" "$@"
elif command -v "$CMD" >/dev/null 2>&1; then
    exec "$CMD" "$@"
elif [ -n "$FALLBACK_CMD" ] && command -v "$FALLBACK_CMD" >/dev/null 2>&1; then
    exec "$FALLBACK_CMD" "$@"
else
    echo "Error: Neither ARGV0 ('${ARGV0%.*}') nor ARGS ('$CMD') are available in \$PATH"
    exit 1
fi
